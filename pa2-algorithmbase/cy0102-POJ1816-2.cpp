/*
程序设计与算法（二）第一周测验2 拨钟问题 POJ1816
write by xucaimao,20171117,测试通过
首先尝试最笨的九重枚举
学习了采用数组元素作为for循环的变量
*/
#include<cstdio>
#include<cstring>
int clk[9];//时钟初始状态
int tmp[9];//临时数组
int ord[10][9]={//定义九种移动命令
//   A B C D E F G H I
	{0,0,0,0,0,0,0,0,0},//0
	{1,1,0,1,1,0,0,0,0},//"ABDE",
	{1,1,1,0,0,0,0,0,0},//"ABC",
	{0,1,1,0,1,1,0,0,0},//"BCEF",
	{1,0,0,1,0,0,1,0,0},//"ADG",
	{0,1,0,1,1,1,0,1,0},//"BDEFH",
    {0,0,1,0,0,1,0,0,1},//"CFI",
    {0,0,0,1,1,0,1,1,0},//"DEGH",
    {0,0,0,0,0,0,1,1,1},//"GHI",
    {0,0,0,0,1,1,0,1,1}};//"EFHI"};


int main(){
	
	freopen("in-cy0102.txt","r",stdin);
	for(int i=0;i<9;i++)
		scanf("%d",&clk[i]);//读入第i号钟的初始状态

	int i[10];//移动方法

	for(i[1]=0;i[1]<4;i[1]++)//对应第k种移动方法的次数
	for(i[2]=0;i[2]<4;i[2]++)
	for(i[3]=0;i[3]<4;i[3]++)
	for(i[4]=0;i[4]<4;i[4]++)
	for(i[5]=0;i[5]<4;i[5]++)
	for(i[6]=0;i[6]<4;i[6]++)
	for(i[7]=0;i[7]<4;i[7]++)
	for(i[8]=0;i[8]<4;i[8]++)
	for(i[9]=0;i[9]<4;i[9]++){
		int ok=1;
		for(int j=0;j<9;j++){//计算9部钟
			tmp[j]=clk[j];
			for(int k=1;k<=9;k++)//计算9种移动
				tmp[j]+=ord[k][j]*i[k];
			tmp[j]%=4;
			if(tmp[j]){ok=0;break;}//第j部钟非零，跳出进行下一步枚举
		}

		if(ok){//9部钟计算完毕，没有出现非零，说明满足条件
			int t=0;
			for(int j=1;j<=9;j++)
				if(i[j]){//有此种移动方法
					for(int k=0;k<i[j];k++){
						if(t>0)printf(" %d",j);
						else printf("%d",j);
						t++;
					}
				}
			printf("\n");
			//找到一种解就退出
			return 0;
		}
	}

	return 0;
}